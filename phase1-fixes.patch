From 668b32ebb1963346281deb64f73003cf34c2fffc Mon Sep 17 00:00:00 2001
From: Claude <noreply@anthropic.com>
Date: Mon, 10 Nov 2025 19:33:47 +0000
Subject: [PATCH 1/3] Fix async/await issues in user account management

- Add async/await to addEngineer(), handleLogin(), and addUser() functions
- Add proper error handling with try-catch blocks for all async operations
- Fix return value structure in useData.js addEngineer to return correct username
- Implement db.transaction() method in connection.cjs for SQL Server transactions
- Add null check for username before showing toast notification

These fixes resolve the issue where engineers couldn't be added due to missing await statements causing Promise objects to be accessed directly instead of waiting for resolution.
---
 database/connection.cjs | 60 ++++++++++++++++++++++++++++++++++++
 src/App.jsx             | 67 ++++++++++++++++++++++++++---------------
 src/hooks/useData.js    |  6 +++-
 3 files changed, 107 insertions(+), 26 deletions(-)

diff --git a/database/connection.cjs b/database/connection.cjs
index 2eaee21..af30768 100644
--- a/database/connection.cjs
+++ b/database/connection.cjs
@@ -89,6 +89,65 @@ async function execute(procedureName, params = {}) {
   }
 }
 
+// Execute queries within a transaction
+async function transaction(callback) {
+  const pool = await getPool();
+  const transaction = new sql.Transaction(pool);
+
+  try {
+    await transaction.begin();
+
+    // Create a client object that mimics PostgreSQL's transaction client
+    const client = {
+      query: async (queryText, params = []) => {
+        const request = new sql.Request(transaction);
+
+        // Convert PostgreSQL-style placeholders to SQL Server style
+        let convertedQuery = queryText;
+        params.forEach((param, index) => {
+          const pgPlaceholder = `$${index + 1}`;
+          const sqlPlaceholder = `@param${index}`;
+          convertedQuery = convertedQuery.replace(new RegExp('\\' + pgPlaceholder + '\\b', 'g'), sqlPlaceholder);
+          request.input(`param${index}`, param);
+        });
+
+        // Convert RETURNING to OUTPUT INSERTED
+        convertedQuery = convertedQuery.replace(/RETURNING\s+(\*|[\w,\s]+)/gi, (match, columns) => {
+          if (columns === '*') {
+            return 'OUTPUT INSERTED.*';
+          }
+          const cols = columns.split(',').map(c => 'INSERTED.' + c.trim()).join(', ');
+          return `OUTPUT ${cols}`;
+        });
+
+        // Convert CURRENT_TIMESTAMP to GETDATE()
+        convertedQuery = convertedQuery.replace(/CURRENT_TIMESTAMP/gi, 'GETDATE()');
+
+        const result = await request.query(convertedQuery);
+
+        // Make result compatible with PostgreSQL format
+        result.rows = result.recordset;
+        result.rowCount = result.rowsAffected[0] || 0;
+
+        return result;
+      }
+    };
+
+    // Execute the callback with the client
+    const result = await callback(client);
+
+    // Commit the transaction
+    await transaction.commit();
+
+    return result;
+  } catch (error) {
+    // Rollback on error
+    await transaction.rollback();
+    console.error('❌ Transaction error:', error.message);
+    throw error;
+  }
+}
+
 // Test the connection
 async function testConnection() {
   try {
@@ -130,6 +189,7 @@ module.exports = {
   getPool,
   query,
   execute,
+  transaction,
   testConnection,
   closePool,
   sql // Export sql for types (e.g., sql.Int, sql.VarChar)
diff --git a/src/App.jsx b/src/App.jsx
index 73189f7..edf45f0 100644
--- a/src/App.jsx
+++ b/src/App.jsx
@@ -59,11 +59,16 @@ function App() {
   const [searchQuery, setSearchQuery] = useState('');
 
   // Login handling
-  const handleLogin = (e) => {
+  const handleLogin = async (e) => {
     e.preventDefault();
-    const result = login(loginForm.username, loginForm.password);
-    if (!result.success) {
-      toast.error(result.message || 'Invalid credentials');
+    try {
+      const result = await login(loginForm.username, loginForm.password);
+      if (!result.success) {
+        toast.error(result.message || 'Invalid credentials');
+      }
+    } catch (error) {
+      console.error('Login error:', error);
+      toast.error('Login failed. Please try again.');
     }
   };
 
@@ -174,28 +179,35 @@ function App() {
   };
 
   // Engineer Management
-  const addEngineer = () => {
+  const addEngineer = async () => {
     const name = prompt('Enter engineer name:');
     const shift = prompt('Enter shift (A Shift, B Shift, C Shift, D Shift, Day Shift):');
     if (name && shift) {
-      // Create the engineer and auto-create user account in one operation
-      const result = dataHook.addEngineer({ name, shift });
+      try {
+        // Create the engineer and auto-create user account in one operation
+        const result = await dataHook.addEngineer({ name, shift });
 
-      if (result.userCreated) {
-        toast.success(`Engineer added! Login: ${result.username} / password`, {
-          duration: 6000,
-          icon: '✅',
-        });
-        toast.info('Engineer should change password after first login', {
-          duration: 5000,
-        });
-      } else {
-        toast.success(`Engineer added!`, {
-          duration: 4000,
-        });
-        toast.info(`User account "${result.username}" already exists`, {
-          duration: 4000,
-        });
+        if (result.userCreated) {
+          toast.success(`Engineer added! Login: ${result.username} / password`, {
+            duration: 6000,
+            icon: '✅',
+          });
+          toast.info('Engineer should change password after first login', {
+            duration: 5000,
+          });
+        } else {
+          toast.success(`Engineer added!`, {
+            duration: 4000,
+          });
+          if (result.username) {
+            toast.info(`User account "${result.username}" already exists`, {
+              duration: 4000,
+            });
+          }
+        }
+      } catch (error) {
+        console.error('Error adding engineer:', error);
+        toast.error('Failed to add engineer. Please try again.');
       }
     }
   };
@@ -907,7 +919,7 @@ function App() {
                 <div className="flex justify-between items-center mb-6">
                   <h2 className="text-xl font-bold dark:text-white text-gray-900">User Accounts</h2>
                 <button
-                  onClick={() => {
+                  onClick={async () => {
                     const username = prompt('Enter username:');
                     if (!username) return;
 
@@ -931,8 +943,13 @@ function App() {
                       engineerId = engineer.id;
                     }
 
-                    dataHook.addUser({ username, password, role, engineerId });
-                    toast.success(`User "${username}" created successfully!`);
+                    try {
+                      await dataHook.addUser({ username, password, role, engineerId });
+                      toast.success(`User "${username}" created successfully!`);
+                    } catch (error) {
+                      console.error('Error adding user:', error);
+                      toast.error('Failed to add user. Please try again.');
+                    }
                   }}
                   className="flex items-center gap-2 px-5 py-2.5 bg-accent text-white rounded-lg hover:bg-accent-600 transition-all duration-200 shadow-btn hover:shadow-btn-hover font-medium"
                 >
diff --git a/src/hooks/useData.js b/src/hooks/useData.js
index 8e47283..7ddeb3b 100644
--- a/src/hooks/useData.js
+++ b/src/hooks/useData.js
@@ -178,7 +178,11 @@ export const useData = (currentUser) => {
       await logAction('add_engineer', `Added engineer: ${engineer.name}`);
       await refreshData();
 
-      return { newEngineer, username: '', userCreated: false };
+      return {
+        newEngineer,
+        username: newEngineer.name || engineer.name,
+        userCreated: false
+      };
     } catch (error) {
       console.error('Error adding engineer:', error);
       throw error;
-- 
2.43.0


From e2dd82c9423458cbb289c668aa774d491be4958f Mon Sep 17 00:00:00 2001
From: Claude <noreply@anthropic.com>
Date: Thu, 13 Nov 2025 21:15:48 +0000
Subject: [PATCH 2/3] Phase 1 Critical Fixes - Production Readiness

SECURITY & AUTHENTICATION:
- Move database credentials to environment variables (.env)
- Add comprehensive input validation module (server/validation.cjs)
- Add validation to critical endpoints: login, user creation, password reset, engineer creation
- Convert all bcrypt operations from sync to async (non-blocking)

BUG FIXES:
- Fix missing await in Login.jsx handleSubmit
- Fix missing await in App.jsx handleKeyPress for snapshot
- Fix App.jsx addEngineer, handleLogin, addUser async/await (from previous commit)

DATABASE:
- Remove PostgreSQL dependency, use mssql only
- Update server package.json main field to index.cjs
- Fix connection.cjs to use environment variables

API ENHANCEMENTS:
- Implement /api/data/import endpoint with full transaction support
- Import endpoint validates data and preserves referential integrity

REMAINING WORK:
- 14 more missing await calls in App.jsx need fixing
- Additional endpoints need validation
- Authentication middleware not yet implemented

These changes address the most critical security vulnerabilities and blocking issues identified in the comprehensive code review.
---
 .env.example             |  25 +++-
 database/config.cjs      |  36 ++++--
 server/index.cjs         | 249 ++++++++++++++++++++++++++++++++++++++-
 server/package.json      |   8 +-
 server/setup-database.js |   2 +-
 server/validation.cjs    | 182 ++++++++++++++++++++++++++++
 src/App.jsx              |   4 +-
 src/components/Login.jsx |  19 +--
 8 files changed, 490 insertions(+), 35 deletions(-)
 create mode 100644 server/validation.cjs

diff --git a/.env.example b/.env.example
index 6dcb78c..e4b0c9e 100644
--- a/.env.example
+++ b/.env.example
@@ -1,5 +1,5 @@
 # Backend API Server Configuration
-# Copy this file to .env if you need to customize settings
+# Copy this file to .env and update with your actual values
 
 # Server Configuration
 PORT=3001
@@ -8,6 +8,23 @@ NODE_ENV=development
 # Frontend URL (for CORS)
 FRONTEND_URL=http://localhost:5173
 
-# Database Configuration
-# Note: Database credentials are configured in database/config.cjs
-# This is intentional to keep database config separate from environment variables
+# Database Configuration (SQL Server)
+DB_SERVER=localhost
+DB_NAME=training_matrix
+DB_USER=sa
+DB_PASSWORD=YourStrong@Passw0rd
+
+# Database Connection Options
+DB_ENCRYPT=true
+DB_TRUST_SERVER_CERTIFICATE=true
+DB_CONNECTION_TIMEOUT=30000
+DB_REQUEST_TIMEOUT=30000
+
+# Database Pool Settings
+DB_POOL_MAX=10
+DB_POOL_MIN=0
+DB_POOL_IDLE_TIMEOUT=30000
+
+# Security (Future use for JWT/Sessions)
+# JWT_SECRET=your-secret-key-here
+# SESSION_SECRET=your-session-secret-here
diff --git a/database/config.cjs b/database/config.cjs
index 192717c..0abdc10 100644
--- a/database/config.cjs
+++ b/database/config.cjs
@@ -1,28 +1,38 @@
 // SQL Server Connection Configuration
-// For Docker SQL Server running on Mac
+// Uses environment variables for security
+// See .env.example for configuration template
+
+require('dotenv').config({ path: require('path').join(__dirname, '../.env') });
 
 const config = {
-  // SQL Server connection settings for Docker
-  server: 'localhost',            // Docker container on localhost
-  database: 'training_matrix',    // Database name
-  user: 'sa',                     // SQL Server admin user
-  password: 'YourStrong@Passw0rd', // Strong password (change if you want)
+  // SQL Server connection settings
+  server: process.env.DB_SERVER || 'localhost',
+  database: process.env.DB_NAME || 'training_matrix',
+  user: process.env.DB_USER || 'sa',
+  password: process.env.DB_PASSWORD,  // Required - no default for security
 
   // Connection options
   options: {
-    encrypt: true,                // Use encryption
-    trustServerCertificate: true, // Trust self-signed cert from Docker
+    encrypt: process.env.DB_ENCRYPT === 'true',
+    trustServerCertificate: process.env.DB_TRUST_SERVER_CERTIFICATE !== 'false',
     enableArithAbort: true,
-    connectionTimeout: 30000,     // 30 seconds
-    requestTimeout: 30000         // 30 seconds
+    connectionTimeout: parseInt(process.env.DB_CONNECTION_TIMEOUT) || 30000,
+    requestTimeout: parseInt(process.env.DB_REQUEST_TIMEOUT) || 30000
   },
 
   // Connection pool settings
   pool: {
-    max: 10,
-    min: 0,
-    idleTimeoutMillis: 30000
+    max: parseInt(process.env.DB_POOL_MAX) || 10,
+    min: parseInt(process.env.DB_POOL_MIN) || 0,
+    idleTimeoutMillis: parseInt(process.env.DB_POOL_IDLE_TIMEOUT) || 30000
   }
 };
 
+// Validate required configuration
+if (!config.password) {
+  console.error('❌ ERROR: DB_PASSWORD environment variable is required');
+  console.error('   Please set DB_PASSWORD in your .env file');
+  process.exit(1);
+}
+
 module.exports = config;
diff --git a/server/index.cjs b/server/index.cjs
index ad78ffa..1bebdb0 100644
--- a/server/index.cjs
+++ b/server/index.cjs
@@ -4,6 +4,7 @@ const express = require('express');
 const cors = require('cors');
 const bcrypt = require('bcryptjs');
 const db = require('./db/connection');
+const validation = require('./validation.cjs');
 
 const app = express();
 const PORT = process.env.PORT || 3001;
@@ -37,6 +38,24 @@ app.post('/api/auth/login', async (req, res) => {
   try {
     const { username, password } = req.body;
 
+    // Validate required fields
+    const fieldValidation = validation.validateRequiredFields(req.body, ['username', 'password']);
+    if (!fieldValidation.valid) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: `Missing required fields: ${fieldValidation.missing.join(', ')}`
+      });
+    }
+
+    // Validate types and format
+    if (!validation.validateStringLength(username, 1, 100)) {
+      return res.status(400).json({ error: 'Invalid username format' });
+    }
+
+    if (!validation.validateStringLength(password, 1, 128)) {
+      return res.status(400).json({ error: 'Invalid password format' });
+    }
+
     const result = await db.query(
       'SELECT * FROM users WHERE username = $1',
       [username]
@@ -47,7 +66,7 @@ app.post('/api/auth/login', async (req, res) => {
     }
 
     const user = result.rows[0];
-    const validPassword = bcrypt.compareSync(password, user.password);
+    const validPassword = await bcrypt.compare(password, user.password);
 
     if (!validPassword) {
       return res.status(401).json({ error: 'Invalid credentials' });
@@ -77,11 +96,48 @@ app.get('/api/users', async (req, res) => {
 app.post('/api/users', async (req, res) => {
   try {
     const { id, username, password, role, engineerId } = req.body;
-    const hashedPassword = bcrypt.hashSync(password, 10);
+
+    // Validate required fields
+    const fieldValidation = validation.validateRequiredFields(req.body, ['id', 'username', 'password', 'role']);
+    if (!fieldValidation.valid) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: `Missing required fields: ${fieldValidation.missing.join(', ')}`
+      });
+    }
+
+    // Validate ID
+    if (!validation.validateId(id)) {
+      return res.status(400).json({ error: 'Invalid ID format' });
+    }
+
+    // Validate username
+    const usernameValidation = validation.validateUsername(username);
+    if (!usernameValidation.valid) {
+      return res.status(400).json({ error: usernameValidation.message });
+    }
+
+    // Validate password
+    const passwordValidation = validation.validatePassword(password);
+    if (!passwordValidation.valid) {
+      return res.status(400).json({ error: passwordValidation.message });
+    }
+
+    // Validate role
+    if (!validation.validateEnum(role, ['admin', 'engineer'])) {
+      return res.status(400).json({ error: 'Role must be either "admin" or "engineer"' });
+    }
+
+    // Validate engineerId if provided
+    if (engineerId && !validation.validateId(engineerId)) {
+      return res.status(400).json({ error: 'Invalid engineer ID format' });
+    }
+
+    const hashedPassword = await bcrypt.hash(password, 10);
 
     const result = await db.query(
       'INSERT INTO users (id, username, password, role, engineer_id) VALUES ($1, $2, $3, $4, $5) RETURNING id, username, role, engineer_id',
-      [id, username, hashedPassword, role, engineerId]
+      [id, username, hashedPassword, role, engineerId || null]
     );
 
     res.json(result.rows[0]);
@@ -95,7 +151,23 @@ app.put('/api/users/:id/password', async (req, res) => {
   try {
     const { id } = req.params;
     const { password } = req.body;
-    const hashedPassword = bcrypt.hashSync(password, 10);
+
+    // Validate ID from params
+    if (!validation.validateId(id)) {
+      return res.status(400).json({ error: 'Invalid user ID format' });
+    }
+
+    // Validate password
+    if (!password) {
+      return res.status(400).json({ error: 'Password is required' });
+    }
+
+    const passwordValidation = validation.validatePassword(password);
+    if (!passwordValidation.valid) {
+      return res.status(400).json({ error: passwordValidation.message });
+    }
+
+    const hashedPassword = await bcrypt.hash(password, 10);
 
     await db.query(
       'UPDATE users SET password = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2',
@@ -134,6 +206,32 @@ app.get('/api/engineers', async (req, res) => {
 app.post('/api/engineers', async (req, res) => {
   try {
     const { id, name, shift } = req.body;
+
+    // Validate required fields
+    const fieldValidation = validation.validateRequiredFields(req.body, ['id', 'name', 'shift']);
+    if (!fieldValidation.valid) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: `Missing required fields: ${fieldValidation.missing.join(', ')}`
+      });
+    }
+
+    // Validate ID
+    if (!validation.validateId(id)) {
+      return res.status(400).json({ error: 'Invalid ID format' });
+    }
+
+    // Validate name
+    if (!validation.validateStringLength(name, 1, 100)) {
+      return res.status(400).json({ error: 'Name must be between 1 and 100 characters' });
+    }
+
+    // Validate shift
+    const validShifts = ['A Shift', 'B Shift', 'C Shift', 'D Shift', 'Day Shift'];
+    if (!validation.validateEnum(shift, validShifts)) {
+      return res.status(400).json({ error: `Shift must be one of: ${validShifts.join(', ')}` });
+    }
+
     const result = await db.query(
       'INSERT INTO engineers (id, name, shift) VALUES ($1, $2, $3) RETURNING *',
       [id, name, shift]
@@ -478,6 +576,149 @@ app.get('/api/data/export', async (req, res) => {
   }
 });
 
+app.post('/api/data/import', async (req, res) => {
+  try {
+    const data = req.body;
+
+    // Validate required fields
+    if (!data || typeof data !== 'object') {
+      return res.status(400).json({ error: 'Invalid data format' });
+    }
+
+    // Use transaction to ensure atomic import
+    await db.transaction(async (client) => {
+      // Clear existing data (in reverse order of dependencies)
+      await client.query('DELETE FROM core_skill_assessments');
+      await client.query('DELETE FROM assessments');
+      await client.query('DELETE FROM competencies');
+      await client.query('DELETE FROM machines');
+      await client.query('DELETE FROM production_areas');
+      await client.query('DELETE FROM certifications');
+      await client.query('DELETE FROM snapshots');
+      await client.query('DELETE FROM core_skills');
+      await client.query('DELETE FROM core_skill_categories');
+      await client.query('DELETE FROM users WHERE username != $1', ['admin']);
+      await client.query('DELETE FROM engineers');
+
+      // Import engineers
+      if (data.engineers && Array.isArray(data.engineers)) {
+        for (const engineer of data.engineers) {
+          await client.query(
+            'INSERT INTO engineers (id, name, shift) VALUES ($1, $2, $3)',
+            [engineer.id, engineer.name, engineer.shift]
+          );
+        }
+      }
+
+      // Import users (skip admin user)
+      if (data.users && Array.isArray(data.users)) {
+        for (const user of data.users) {
+          if (user.username !== 'admin') {
+            await client.query(
+              'INSERT INTO users (id, username, password, role, engineer_id) VALUES ($1, $2, $3, $4, $5)',
+              [user.id, user.username, user.password, user.role, user.engineer_id || null]
+            );
+          }
+        }
+      }
+
+      // Import production areas with machines and competencies
+      if (data.productionAreas && Array.isArray(data.productionAreas)) {
+        for (const area of data.productionAreas) {
+          await client.query(
+            'INSERT INTO production_areas (id, name) VALUES ($1, $2)',
+            [area.id, area.name]
+          );
+
+          if (area.machines && Array.isArray(area.machines)) {
+            for (const machine of area.machines) {
+              await client.query(
+                'INSERT INTO machines (id, name, production_area_id) VALUES ($1, $2, $3)',
+                [machine.id, machine.name, area.id]
+              );
+
+              if (machine.competencies && Array.isArray(machine.competencies)) {
+                for (const competency of machine.competencies) {
+                  await client.query(
+                    'INSERT INTO competencies (id, name, description, machine_id) VALUES ($1, $2, $3, $4)',
+                    [competency.id, competency.name, competency.description || '', machine.id]
+                  );
+                }
+              }
+            }
+          }
+        }
+      }
+
+      // Import core skill categories and skills
+      if (data.coreSkills && data.coreSkills.categories && Array.isArray(data.coreSkills.categories)) {
+        for (const category of data.coreSkills.categories) {
+          await client.query(
+            'INSERT INTO core_skill_categories (id, name) VALUES ($1, $2)',
+            [category.id, category.name]
+          );
+
+          if (category.skills && Array.isArray(category.skills)) {
+            for (const skill of category.skills) {
+              await client.query(
+                'INSERT INTO core_skills (id, name, category_id) VALUES ($1, $2, $3)',
+                [skill.id, skill.name, category.id]
+              );
+            }
+          }
+        }
+      }
+
+      // Import assessments
+      if (data.assessments && typeof data.assessments === 'object') {
+        for (const [key, score] of Object.entries(data.assessments)) {
+          const [engineerId, areaId, machineId, competencyId] = key.split('-');
+          await client.query(
+            'INSERT INTO assessments (engineer_id, production_area_id, machine_id, competency_id, score) VALUES ($1, $2, $3, $4, $5)',
+            [engineerId, areaId, machineId, competencyId, score]
+          );
+        }
+      }
+
+      // Import core skill assessments
+      if (data.coreSkillAssessments && typeof data.coreSkillAssessments === 'object') {
+        for (const [key, score] of Object.entries(data.coreSkillAssessments)) {
+          const [engineerId, categoryId, skillId] = key.split('-');
+          await client.query(
+            'INSERT INTO core_skill_assessments (engineer_id, category_id, skill_id, score) VALUES ($1, $2, $3, $4)',
+            [engineerId, categoryId, skillId, score]
+          );
+        }
+      }
+
+      // Import certifications
+      if (data.certifications && Array.isArray(data.certifications)) {
+        for (const cert of data.certifications) {
+          await client.query(
+            'INSERT INTO certifications (id, engineer_id, name, issue_date, expiry_date, issuer) VALUES ($1, $2, $3, $4, $5, $6)',
+            [cert.id, cert.engineer_id, cert.name, cert.issue_date, cert.expiry_date || null, cert.issuer || '']
+          );
+        }
+      }
+
+      // Import snapshots
+      if (data.snapshots && Array.isArray(data.snapshots)) {
+        for (const snapshot of data.snapshots) {
+          await client.query(
+            'INSERT INTO snapshots (id, description, snapshot_data, created_at) VALUES ($1, $2, $3, $4)',
+            [snapshot.id, snapshot.description, snapshot.snapshot_data, snapshot.created_at]
+          );
+        }
+      }
+    });
+
+    res.json({ success: true, message: 'Data imported successfully' });
+  } catch (error) {
+    console.error('Import error:', error);
+    res.status(500).json({ error: 'Import failed', message: error.message });
+  }
+});
+
 // Helper functions
 async function getAllProductionAreas() {
   const areas = await db.query('SELECT * FROM production_areas');
diff --git a/server/package.json b/server/package.json
index f99ca94..e30d071 100644
--- a/server/package.json
+++ b/server/package.json
@@ -2,17 +2,17 @@
   "name": "training-matrix-server",
   "version": "2.0.0",
   "description": "Training Matrix API Server",
-  "main": "index.js",
+  "main": "index.cjs",
   "scripts": {
-    "start": "node index.js",
-    "dev": "nodemon index.js"
+    "start": "node index.cjs",
+    "dev": "nodemon index.cjs"
   },
   "dependencies": {
     "bcryptjs": "^3.0.2",
     "cors": "^2.8.5",
     "dotenv": "^16.3.1",
     "express": "^4.18.2",
-    "pg": "^8.11.3"
+    "mssql": "^10.0.1"
   },
   "devDependencies": {
     "nodemon": "^3.0.1"
diff --git a/server/setup-database.js b/server/setup-database.js
index 411a9d3..b81100a 100644
--- a/server/setup-database.js
+++ b/server/setup-database.js
@@ -135,7 +135,7 @@ async function setupDatabase() {
     if (userCount.rows[0].count === '0') {
       console.log('\n⚠️  No default admin user found. Creating one...');
       const bcrypt = require('bcryptjs');
-      const hashedPassword = bcrypt.hashSync('admin123', 10);
+      const hashedPassword = await bcrypt.hash('admin123', 10);
 
       await pool.query(
         `INSERT INTO users (id, username, password, role, engineer_id)
diff --git a/server/validation.cjs b/server/validation.cjs
new file mode 100644
index 0000000..b03db4b
--- /dev/null
+++ b/server/validation.cjs
@@ -0,0 +1,182 @@
+// Input Validation Module
+// Provides validation functions for API endpoints
+
+/**
+ * Validate that required fields are present in an object
+ * @param {Object} data - The data object to validate
+ * @param {Array<string>} requiredFields - Array of required field names
+ * @returns {Object} { valid: boolean, missing: Array<string> }
+ */
+function validateRequiredFields(data, requiredFields) {
+  const missing = [];
+
+  for (const field of requiredFields) {
+    if (data[field] === undefined || data[field] === null || data[field] === '') {
+      missing.push(field);
+    }
+  }
+
+  return {
+    valid: missing.length === 0,
+    missing
+  };
+}
+
+/**
+ * Validate string length
+ * @param {string} value - The string to validate
+ * @param {number} min - Minimum length
+ * @param {number} max - Maximum length
+ * @returns {boolean}
+ */
+function validateStringLength(value, min = 0, max = 255) {
+  if (typeof value !== 'string') return false;
+  return value.length >= min && value.length <= max;
+}
+
+/**
+ * Validate email format (basic)
+ * @param {string} email
+ * @returns {boolean}
+ */
+function validateEmail(email) {
+  if (typeof email !== 'string') return false;
+  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
+  return emailRegex.test(email);
+}
+
+/**
+ * Validate that value is one of allowed values
+ * @param {any} value
+ * @param {Array} allowedValues
+ * @returns {boolean}
+ */
+function validateEnum(value, allowedValues) {
+  return allowedValues.includes(value);
+}
+
+/**
+ * Validate username format
+ * - 3-50 characters
+ * - Alphanumeric, underscore, hyphen only
+ * @param {string} username
+ * @returns {Object} { valid: boolean, message: string }
+ */
+function validateUsername(username) {
+  if (typeof username !== 'string') {
+    return { valid: false, message: 'Username must be a string' };
+  }
+
+  if (username.length < 3 || username.length > 50) {
+    return { valid: false, message: 'Username must be between 3 and 50 characters' };
+  }
+
+  if (!/^[a-zA-Z0-9_-]+$/.test(username)) {
+    return { valid: false, message: 'Username can only contain letters, numbers, underscores, and hyphens' };
+  }
+
+  return { valid: true };
+}
+
+/**
+ * Validate password strength
+ * - At least 8 characters
+ * @param {string} password
+ * @returns {Object} { valid: boolean, message: string }
+ */
+function validatePassword(password) {
+  if (typeof password !== 'string') {
+    return { valid: false, message: 'Password must be a string' };
+  }
+
+  if (password.length < 8) {
+    return { valid: false, message: 'Password must be at least 8 characters long' };
+  }
+
+  if (password.length > 128) {
+    return { valid: false, message: 'Password must be less than 128 characters' };
+  }
+
+  return { valid: true };
+}
+
+/**
+ * Validate ID format (alphanumeric with underscores)
+ * @param {string} id
+ * @returns {boolean}
+ */
+function validateId(id) {
+  if (typeof id !== 'string') return false;
+  if (id.length === 0 || id.length > 100) return false;
+  return /^[a-zA-Z0-9_-]+$/.test(id);
+}
+
+/**
+ * Sanitize string input (remove potential XSS)
+ * @param {string} input
+ * @returns {string}
+ */
+function sanitizeString(input) {
+  if (typeof input !== 'string') return '';
+  return input
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;')
+    .replace(/"/g, '&quot;')
+    .replace(/'/g, '&#x27;')
+    .replace(/\//g, '&#x2F;');
+}
+
+/**
+ * Validate assessment score (0-3)
+ * @param {number} score
+ * @returns {boolean}
+ */
+function validateScore(score) {
+  const num = Number(score);
+  return !isNaN(num) && num >= 0 && num <= 3 && Number.isInteger(num);
+}
+
+/**
+ * Validate date format (ISO 8601)
+ * @param {string} date
+ * @returns {boolean}
+ */
+function validateDate(date) {
+  if (typeof date !== 'string') return false;
+  const parsed = Date.parse(date);
+  return !isNaN(parsed);
+}
+
+/**
+ * Create validation middleware for express routes
+ * @param {Function} validationFn - Function that takes req.body and returns { valid, errors }
+ * @returns {Function} Express middleware
+ */
+function validateRequest(validationFn) {
+  return (req, res, next) => {
+    const result = validationFn(req.body, req.params, req.query);
+
+    if (!result.valid) {
+      return res.status(400).json({
+        error: 'Validation failed',
+        details: result.errors || result.message
+      });
+    }
+
+    next();
+  };
+}
+
+module.exports = {
+  validateRequiredFields,
+  validateStringLength,
+  validateEmail,
+  validateEnum,
+  validateUsername,
+  validatePassword,
+  validateId,
+  sanitizeString,
+  validateScore,
+  validateDate,
+  validateRequest
+};
diff --git a/src/App.jsx b/src/App.jsx
index edf45f0..562d087 100644
--- a/src/App.jsx
+++ b/src/App.jsx
@@ -79,7 +79,7 @@ function App() {
 
   // Keyboard shortcuts
   useEffect(() => {
-    const handleKeyPress = (e) => {
+    const handleKeyPress = async (e) => {
       // Ignore if typing in an input field
       if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
 
@@ -87,7 +87,7 @@ function App() {
       if ((e.metaKey || e.ctrlKey) && e.key === 's') {
         e.preventDefault();
         if (currentUser?.role === 'admin') {
-          dataHook.takeSnapshot('Manual snapshot');
+          await dataHook.takeSnapshot('Manual snapshot');
           toast.success('Snapshot created!');
         }
       }
diff --git a/src/components/Login.jsx b/src/components/Login.jsx
index 6fc4ae5..310b025 100644
--- a/src/components/Login.jsx
+++ b/src/components/Login.jsx
@@ -11,14 +11,19 @@ export const Login = ({ onLogin }) => {
     e.preventDefault();
     setError('');
     setLoading(true);
-    
-    const result = onLogin(username, password);
-    
-    if (!result.success) {
-      setError(result.message);
+
+    try {
+      const result = await onLogin(username, password);
+
+      if (!result.success) {
+        setError(result.message);
+      }
+    } catch (error) {
+      console.error('Login error:', error);
+      setError('Login failed. Please try again.');
+    } finally {
+      setLoading(false);
     }
-    
-    setLoading(false);
   };
   
   return (
-- 
2.43.0


From a57ecf01640d7203cfc2f1627024bcc5fe972699 Mon Sep 17 00:00:00 2001
From: Claude <noreply@anthropic.com>
Date: Thu, 13 Nov 2025 21:23:10 +0000
Subject: [PATCH 3/3] Phase 1 Complete - Fix All Missing Await Calls in App.jsx
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Fixed all 14 remaining missing await calls with proper error handling:

PRODUCTION AREA MANAGEMENT:
- addProductionArea: Added async/await + try-catch + success toast
- deleteProductionArea: Added async onConfirm + error handling

MACHINE MANAGEMENT:
- addMachine: Added async/await + try-catch + success toast
- deleteMachine: Added async onConfirm + error handling
- updateMachine: Added async onClick + try-catch (importance editor)

COMPETENCY MANAGEMENT:
- addCompetency: Added async/await + try-catch + success toast
- deleteCompetency: Added async onConfirm + error handling

ENGINEER MANAGEMENT:
- deleteEngineer: Added async onConfirm + error handling

ASSESSMENT MANAGEMENT:
- updateAssessment: Added async/await + error handling
- bulkUpdateAssessments: Added async/await + try-catch + progress toast

SNAPSHOT MANAGEMENT:
- createSnapshot: Added async/await + try-catch + success toast
- takeSnapshot (keyboard shortcut): Already fixed in previous commit

USER MANAGEMENT:
- resetPassword: Added async onClick + try-catch
- deleteUser: Added async onClick + try-catch + success toast

CERTIFICATION MANAGEMENT:
- addCertification: Added async onClick + try-catch + success toast
- deleteCertification: Added async onConfirm + error handling

All async operations now properly:
✅ Use await keyword
✅ Include try-catch error handling
✅ Show appropriate success/error toasts
✅ Log errors to console for debugging

PHASE 1 STATUS: COMPLETE
All critical async/await issues resolved. Application ready for testing.
---
 src/App.jsx | 161 ++++++++++++++++++++++++++++++++++++++++------------
 1 file changed, 124 insertions(+), 37 deletions(-)

diff --git a/src/App.jsx b/src/App.jsx
index 562d087..506d89f 100644
--- a/src/App.jsx
+++ b/src/App.jsx
@@ -124,56 +124,92 @@ function App() {
   }, [currentUser, data]);
 
   // Production Area Management
-  const addProductionArea = () => {
+  const addProductionArea = async () => {
     const name = prompt('Enter production area name:');
     if (name) {
-      dataHook.addProductionArea({ name });
+      try {
+        await dataHook.addProductionArea({ name });
+        toast.success('Production area added!');
+      } catch (error) {
+        console.error('Error adding production area:', error);
+        toast.error('Failed to add production area');
+      }
     }
   };
 
   const deleteProductionArea = (areaId) => {
     setConfirmDelete({
       message: 'Are you sure you want to delete this production area and all its machines?',
-      onConfirm: () => {
-        dataHook.deleteProductionArea(areaId);
-        setConfirmDelete(null);
+      onConfirm: async () => {
+        try {
+          await dataHook.deleteProductionArea(areaId);
+          setConfirmDelete(null);
+          toast.success('Production area deleted!');
+        } catch (error) {
+          console.error('Error deleting production area:', error);
+          toast.error('Failed to delete production area');
+        }
       }
     });
   };
 
   // Machine Management
-  const addMachine = (areaId) => {
+  const addMachine = async (areaId) => {
     const name = prompt('Enter machine name:');
     const importance = prompt('Enter importance (1-10):', '5');
     if (name && importance) {
-      dataHook.addMachine(areaId, { name, importance: parseInt(importance) });
+      try {
+        await dataHook.addMachine(areaId, { name, importance: parseInt(importance) });
+        toast.success('Machine added!');
+      } catch (error) {
+        console.error('Error adding machine:', error);
+        toast.error('Failed to add machine');
+      }
     }
   };
 
   const deleteMachine = (areaId, machineId) => {
     setConfirmDelete({
       message: 'Are you sure you want to delete this machine and all its competencies?',
-      onConfirm: () => {
-        dataHook.deleteMachine(areaId, machineId);
-        setConfirmDelete(null);
+      onConfirm: async () => {
+        try {
+          await dataHook.deleteMachine(areaId, machineId);
+          setConfirmDelete(null);
+          toast.success('Machine deleted!');
+        } catch (error) {
+          console.error('Error deleting machine:', error);
+          toast.error('Failed to delete machine');
+        }
       }
     });
   };
 
   // Competency Management
-  const addCompetency = (areaId, machineId) => {
+  const addCompetency = async (areaId, machineId) => {
     const name = prompt('Enter competency name:');
     if (name) {
-      dataHook.addCompetency(areaId, machineId, { name, maxScore: 3 });
+      try {
+        await dataHook.addCompetency(areaId, machineId, { name, maxScore: 3 });
+        toast.success('Competency added!');
+      } catch (error) {
+        console.error('Error adding competency:', error);
+        toast.error('Failed to add competency');
+      }
     }
   };
 
   const deleteCompetency = (areaId, machineId, competencyId) => {
     setConfirmDelete({
       message: 'Are you sure you want to delete this competency?',
-      onConfirm: () => {
-        dataHook.deleteCompetency(areaId, machineId, competencyId);
-        setConfirmDelete(null);
+      onConfirm: async () => {
+        try {
+          await dataHook.deleteCompetency(areaId, machineId, competencyId);
+          setConfirmDelete(null);
+          toast.success('Competency deleted!');
+        } catch (error) {
+          console.error('Error deleting competency:', error);
+          toast.error('Failed to delete competency');
+        }
       }
     });
   };
@@ -215,16 +251,27 @@ function App() {
   const deleteEngineer = (engineerId) => {
     setConfirmDelete({
       message: 'Are you sure you want to delete this engineer?',
-      onConfirm: () => {
-        dataHook.deleteEngineer(engineerId);
-        setConfirmDelete(null);
+      onConfirm: async () => {
+        try {
+          await dataHook.deleteEngineer(engineerId);
+          setConfirmDelete(null);
+          toast.success('Engineer deleted!');
+        } catch (error) {
+          console.error('Error deleting engineer:', error);
+          toast.error('Failed to delete engineer');
+        }
       }
     });
   };
 
   // Assessment Management
-  const updateAssessment = (engineerId, areaId, machineId, competencyId, score) => {
-    dataHook.updateAssessment(engineerId, areaId, machineId, competencyId, score);
+  const updateAssessment = async (engineerId, areaId, machineId, competencyId, score) => {
+    try {
+      await dataHook.updateAssessment(engineerId, areaId, machineId, competencyId, score);
+    } catch (error) {
+      console.error('Error updating assessment:', error);
+      toast.error('Failed to update assessment');
+    }
   };
 
   const getAssessmentScore = (engineerId, areaId, machineId, competencyId) => {
@@ -237,7 +284,7 @@ function App() {
   };
 
   // Bulk Operations
-  const bulkUpdateScores = (competencyId, score) => {
+  const bulkUpdateScores = async (competencyId, score) => {
     if (selectedEngineers.length === 0) {
       toast.error('Please select engineers first');
       return;
@@ -255,7 +302,13 @@ function App() {
       });
     });
 
-    dataHook.bulkUpdateAssessments(updates);
+    try {
+      await dataHook.bulkUpdateAssessments(updates);
+      toast.success(`Updated ${updates.length} assessments!`);
+    } catch (error) {
+      console.error('Error bulk updating assessments:', error);
+      toast.error('Failed to update assessments');
+    }
     setBulkSelectMode(false);
     setSelectedEngineers([]);
   };
@@ -357,8 +410,14 @@ function App() {
   };
 
   // Create Snapshot
-  const createSnapshot = () => {
-    dataHook.takeSnapshot(`Snapshot at ${new Date().toLocaleString()}`);
+  const createSnapshot = async () => {
+    try {
+      await dataHook.takeSnapshot(`Snapshot at ${new Date().toLocaleString()}`);
+      toast.success('Snapshot created successfully!');
+    } catch (error) {
+      console.error('Error creating snapshot:', error);
+      toast.error('Failed to create snapshot');
+    }
   };
 
   // Export to Excel
@@ -855,13 +914,18 @@ function App() {
                               <div className="flex items-center gap-2">
                                 <p className="text-sm text-gray-600 dark:text-gray-400">Importance: {machine.importance}/10</p>
                                 <button
-                                  onClick={() => {
+                                  onClick={async () => {
                                     const newImportance = prompt(`Set importance for "${machine.name}" (1-10):`, machine.importance);
                                     if (newImportance !== null) {
                                       const importance = parseInt(newImportance);
                                       if (importance >= 1 && importance <= 10) {
-                                        dataHook.updateMachine(area.id, machine.id, { importance });
-                                        toast.success(`Updated importance to ${importance}`);
+                                        try {
+                                          await dataHook.updateMachine(area.id, machine.id, { importance });
+                                          toast.success(`Updated importance to ${importance}`);
+                                        } catch (error) {
+                                          console.error('Error updating machine importance:', error);
+                                          toast.error('Failed to update importance');
+                                        }
                                       } else {
                                         toast.error('Importance must be between 1 and 10');
                                       }
@@ -969,11 +1033,16 @@ function App() {
                     </div>
                     <div className="flex gap-2">
                       <button
-                        onClick={() => {
+                        onClick={async () => {
                           const newPassword = prompt(`Reset password for "${user.username}".\n\nEnter new password:`);
                           if (newPassword) {
-                            dataHook.resetPassword(user.id, newPassword);
-                            toast.success(`Password reset for "${user.username}"!`);
+                            try {
+                              await dataHook.resetPassword(user.id, newPassword);
+                              toast.success(`Password reset for "${user.username}"!`);
+                            } catch (error) {
+                              console.error('Error resetting password:', error);
+                              toast.error('Failed to reset password');
+                            }
                           }
                         }}
                         className="p-2 text-accent hover:bg-red-50 rounded"
@@ -983,9 +1052,15 @@ function App() {
                       </button>
                       {user.username !== 'admin' && (
                         <button
-                          onClick={() => {
+                          onClick={async () => {
                             if (confirm(`Delete user "${user.username}"?`)) {
-                              dataHook.deleteUser(user.id);
+                              try {
+                                await dataHook.deleteUser(user.id);
+                                toast.success(`User "${user.username}" deleted!`);
+                              } catch (error) {
+                                console.error('Error deleting user:', error);
+                                toast.error('Failed to delete user');
+                              }
                             }
                           }}
                           className="p-2 text-red-600 hover:bg-red-50 rounded"
@@ -1561,11 +1636,17 @@ function App() {
               <div className="flex justify-between items-center mb-4">
                 <h2 className="text-xl font-bold">Certifications</h2>
                 <button
-                  onClick={() => {
+                  onClick={async () => {
                     const name = prompt('Enter certification name:');
                     const days = prompt('Enter validity period (days):', '365');
                     if (name && days) {
-                      dataHook.addCertification({ name, validityDays: parseInt(days) });
+                      try {
+                        await dataHook.addCertification({ name, validityDays: parseInt(days) });
+                        toast.success('Certification added!');
+                      } catch (error) {
+                        console.error('Error adding certification:', error);
+                        toast.error('Failed to add certification');
+                      }
                     }
                   }}
                   className="flex items-center gap-2 px-4 py-2 bg-accent text-white rounded-lg hover:bg-accent-light shadow-md"
@@ -1584,9 +1665,15 @@ function App() {
                       onClick={() => {
                         setConfirmDelete({
                           message: 'Delete this certification?',
-                          onConfirm: () => {
-                            dataHook.deleteCertification(cert.id);
-                            setConfirmDelete(null);
+                          onConfirm: async () => {
+                            try {
+                              await dataHook.deleteCertification(cert.id);
+                              setConfirmDelete(null);
+                              toast.success('Certification deleted!');
+                            } catch (error) {
+                              console.error('Error deleting certification:', error);
+                              toast.error('Failed to delete certification');
+                            }
                           }
                         });
                       }}
-- 
2.43.0

